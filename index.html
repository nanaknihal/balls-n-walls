<!DOCTYPE html>
</html>
<head>
  <title>B a l l s  n'  W a l l s </title>
  <script src="jspsych-6.0.3/jspsych.js"></script>
  <script src="jspsych-6.0.3/plugins/jspsych-html-keyboard-response.js"></script>
  <script src="jspsych-6.0.3/plugins/jspsych-image-keyboard-response.js"></script>
  <link href="jspsych-6.0.3/css/jspsych.css" rel="stylesheet" type="text/css"></link>
</head>

<body>
</body>
<script>
var timeline = []

var welcome = {
  type:"html-keyboard-response",
  stimulus:"Welcome to the game. Press any key to begin"
};
timeline.push(welcome);

/*width and height: */
w=650; h=650
var game = {
  type:"html-keyboard-response",
  stimulus: "<!--main canvas where game happens:-->" +
  "<canvas id='mainCanvas' height='" + h + "' width = '" + w + "'></canvas>" + "<button onclick='controller.beginGame()'>S T A R T</button>"
  +
  "<!--overlay canvas that doesn't need to be refreshed constantly:-->" +
  //it may be good to not hard-code the top and left value but rather use variables...this will be decided later when we do more styling
  "<canvas id='overlay' style='position:absolute; left: 0; top: 0; z-index:1' height='" + h + "' width = '" + w + "'></canvas>"

};
timeline.push(game);

/* CODE FROM THE JSPSYCH TUTORIAL:
var blue_trial = {
  type:"image-keyboard-response",
  stimulus: "img/blue.png",
  choices: ["f","j"]
}

var orange_trial = {
  type: "image-keyboard-response",
  stimulus: "img/orange.png",
  choices: ["f", "j"]
}

var test_stimuli = [
  {stimulus: "img/blue.png", data: {test_part: "test", correct_response: "f"}},
  {stimulus: "img/orange.png", data: {test_part: "test", correct_response:"j"}}]
timeline.push(blue_trial,orange_trial);

var fixation = {
  type: "html-keyboard-response",
  stimulus: "<div style='font-size:60px;'>+</div>",
  choices: jsPsych.NO_KEYS,
  trial_duration: jsPsych.randomization.sampleWithoutReplacement(
    [250, 500, 750, 1000, 1250, 1500, 1750, 2000], 1)[0],
  data: {test_part: "fixation"}
}

var test = {
  type:"image-keyboard-response",
  stimulus:jsPsych.timelineVariable("stimulus"),
  choices:["f","j"],
  data:jsPsych.timelineVariable("data"),
  on_finish: function(data){
    data.correct = data.key_press == jsPsych.pluginAPI.convertKeyCharacterToKeyCode(data.correct_response);
  }
}

var test_procedure = {
  timeline:[fixation, test],
  timeline_variables: test_stimuli,
  randomize_order: true,
  repetitions: 5
}
timeline.push(test_procedure);
*/

jsPsych.init({
  timeline: timeline,
  on_finish: function(){
    jsPsych.data.displayData();
  }
})



/*--Game stuff:--*/

var model = {
  gameOver: false,
  //"e" is for explosive
  balls: [new ball(100,220), new ball(200,210,"e"), new ball(200,100), new ball(87,210,"e"), new ball(100,100), new ball(50,50, new ball(400,30), new ball(300,210,"e"))],


  /*MAKE SURE TO NOT MAKE THE WIDTHS NEGATIVE - THE wall.highestPoint, leftestPoint, etc. methods will not work if they
   *are negative. It may be a good idea to make those methods work with negative values, but it seems that would be less
   *efficient because more steps would be involved in those methods, which are called a lot. It also may be good to have
   *the highestPoint, lowestPoint, etc. methods of the four walls at the edges of the canvas only be called once instead
   *of for every ball in every update. Also make sure the balls are not already touching the walls upon initialization*/
   walls: [new wall(0,0,w,1), new wall(0,0,1,h), new wall(0,h-2,w,1), new wall(w-2,0,1,h)], //default border walls of 0px

  /*USER OBSTACLE: a set of pixels that the user selected to be included in the "obstacle." The user probably sees this as
   *"obstacle" as multiple obstacles, but the program treats them all as one. It doesn't care how the pixels are grouped,
   *just where they are.
   *
   *The obstacle has a radius. If a ball is closer than ball.radius + obstacle.radius, a collision will be registered */

    userObstacle : {
      pixels : new Array(),
      radius : 4,
      maxPixels: 400,
      pixelLimitExceeded: false,

      addPixels : function(event){
        //add them if they're not already in the pixels array AND the maximum number of pixels isn't exceeded
        if(!this.pixels.includes([event.pageX, event.pageY]) && this.pixels.length <= this.maxPixels){
          this.pixels.push([event.pageX, event.pageY])
        } else if (this.pixels.length >= this.maxPixels) {
          //if this is the first time exceeding the pixel limit:
          if(!this.pixelLimitExceeded){
            view.message("You can't use too much wall... that would make it easy")
            //set it to true so this message only displays once:
            this.pixelLimitExceeded = true;
          }


        }
      },
      getPixels : function(){return this.pixels},
      getRadius : function(){return this.radius}
    },


  //not necessary to have this function but it's good encapsulation and helps with Law of Demeter (even though it technically violates it)
  //if efficiency is a concern, we can get rid of it:
  addPixelsToUserObstacle : function(event){
    model.userObstacle.addPixels(event)
  },


  getBalls: function(){return this.balls},
  update: function(){

    this.checkForWallCollisions = function(){
    /*update the balls*/
    var updatedBalls = []; //to check for collisions, balls' positions will need to be compared to updated balls - not
                           //non-updated balls.

    for(var i = 0, numBalls = this.balls.length; i < numBalls; i++){

      var ball = this.balls[i];
      cur_x = ball.getX();
      cur_y = ball.getY();



      //check for collision with any previously updated balls:
      //commenting this out because we don't need collisions (maybe will implement later)
      /*
      var ballCollided = false;
      //assuming all balls have same, constant radius! that seems fine for the purpose of this experiment (and is much better for efficiency):
      rad = ball.getRadius();
      rad2 = rad*rad;
      for(var k = 0, numUpdBalls = updatedBalls.length; k < numUpdBalls && !ballCollided/*it will stop on collisions; k++){
        x_diff = cur_x - updatedBalls[k].getX();
        y_diff = cur_y - updatedBalls[k].getY();
        distance = Math.pow(x_diff, 2) + Math.pow(y_diff, 2);



        if(distance < rad2){
          ballCollided == true;
          ball.collide("ball");

        }
      }*/

      //check for collision with any previously updated walls:
      var wallCollided = false;

      for(var k = 0, numWalls = this.walls.length; k < numWalls; k++){

        wall = this.walls[k]


        wall_x = wall.getX()
        wall_y = wall.getY()
        wall_l = wall.getL()
        wall_w = wall.getW()


        rad = ball.getRadius()

        //var bh = ball.highestPoint()
        //var bl = ball.lowestPoint()
        //var be = ball.leftestPoint()
        //var br = ball.rightestPoint()

        var wh = wall.highestPoint()
        var wl = wall.lowestPoint()
        var we = wall.leftestPoint()
        var wr = wall.rightestPoint()

        /*WHEN A BALL INTERSECTS WITH A WALL:
          one of the rectangle's four edges is within the circle's area (closer to the center than the circle).
          When this happens, the circle's center will be closer to a vertical wall's x coordinate than it's radius is
          AND the circle's highest or lowest point will be within the wall's highest and lowest points

          OR

          vice versa with horizontal walls and y coordinates vs. x coordinates
        */

        //NOTE: the following only works with walls that are thinner than the ball. This is a simplifying assumption. There should never be walls
        //thicker than the balls
        collidingWVert = (Math.abs(cur_x - wall_x) < rad) || (Math.abs(cur_x - (wall_x+wall_w)) < rad) //either of the walls' sides
                                                                                                       //x coordinate is closer to the center
                                                                                                       //than the radius is

        collidingWHori = (Math.abs(cur_y - wall_y) < rad) || (Math.abs(cur_y - (wall_y+wall_l)) < rad) //same but with y

        //NOTE: the following only works with walls without negative coordinates, lengths, and widths. making walls like that is unecessary
        //and would necesitate a slower algorithm here, whereas converting negative coordinates to positive coordinates once, upon construction,
        //is more efficient. This is called for every ball and every wall at every update!:
//TRY THIS:  //centerIsWithinWallY = (cur_y >= wh) && (cur_x <= wl)
            //centerIsWithinWallX = (cur_x >= we) && (cur_x <= wr)






        if(collidingWVert || collidingWHori){
          wallCollided == true;
          ball.collide("wall");
          //multiply the velocity by -1 on appropriate axis. but how do we find the appropriate axis?:
            //by looking for the side of the wall the ball is closest to
            var highWallDistance = Math.abs(cur_y - wh)
            var lowWallDistance = Math.abs(cur_y - wl)
            var leftWallDistance = Math.abs(cur_x - we)
            var rightWallDistance = Math.abs(cur_x - wr)
            var wallDistances = [highWallDistance, lowWallDistance, leftWallDistance, rightWallDistance]

            closestWallDistance = wallDistances[0] //initialize it with the first value of the wallDistances array.
                                                   //^this makes sense because of how the loop will iterate:
            //closestWall = "aVerticalWall"

            for(var l = 1; l < 4; l++){
              if(wallDistances[l]/*l starts at 1*/  < closestWallDistance){
                closestWallDistance = wallDistances[l];
              }
            }

        //now multiply the appropriate component of velocity
        vel = ball.getVelocity();
        if((closestWallDistance == highWallDistance) || (closestWallDistance == lowWallDistance)){
          ball.setVelocity([vel[0], -vel[1]])
        } else if ((closestWallDistance == leftWallDistance) || (closestWallDistance == rightWallDistance)) {
          //because it's else if, the upper and lower edges will be prioritized if two of the distances are equal
          ball.setVelocity([-vel[0], vel[1]])
        }

        }
      }
      //move the ball one increment after setting its velocity (or leaving it):
      ball.move()
      updatedBalls.push(ball);
    }
    }

    this.checkForObstacleCollisions = function(){
      //iterate through all the balls and pixels
      for(var i = 0, numBalls = this.balls.length; i < numBalls; i++){
        ball = this.balls[i]
        for(var j = 0, ob = model.userObstacle, pix = ob.getPixels(), numPix = pix.length; j<numPix; j++){
          //if the pixel is within the ball's radius:
            a = Math.abs(pix[j][0] - ball.getX())
            b = Math.abs(pix[j][1] - ball.getY())
            c = ball.getRadius() + ob.getRadius()
            if(a*a + b*b <= c*c){
              //collision has happened! change ball's velocity accordingly:
              //find the neighboring two pixels to calculate the angle of collision at a "miniwall" of 3 pixels:
              p0 = (j == 0 ? pix[j] : pix[j-1]) //if j's 0, there is no pix[j-1] so it should use pix[j] as the starting point
              p1 = (j < numPix-1 ? pix[j+1] : pix[j])

              miniWallXComponent = p1[0]-p0[0] //make sure these work with negative x or y components
              miniWallYComponent = p1[1]-p1[1]
              //arctan of y comp / x comp:
              miniWallAngleFromXAxis = Math.atan2(miniWallYComponent, miniWallYComponent)
              miniWallAngleFromYAxis = Math.PI/2-miniWallAngleFromXAxis

              vi = ball.getVelocity()
              viAngleFromYAxis = Math.atan2(vi[0], vi[1])

              angleBetweenViAndObstaclePoint = miniWallAngleFromYAxis - viAngleFromYAxis //this equals angle_between_vf_and_obstacle_point
                                                                                              //(which isn't an actual variable here)

              angleBetweenVfAndXAxis = Math.PI/2 + miniWallAngleFromXAxis - angleBetweenViAndObstaclePoint //this is easier to see visually

              vMagnitude = Math.sqrt(vi[0]*vi[0] + vi[1]*vi[1]) //Pythagorean theorem

              vfX = vMagnitude * Math.cos(angleBetweenVfAndXAxis)
              vfY = vMagnitude * Math.sin(angleBetweenVfAndXAxis)
              ball.setVelocity(vfX, vfY)
              ball.move()
            }
        }
      }

    }
    this.checkForWallCollisions()
    this.checkForObstacleCollisions()


  }
}

//constructor for balls: (x and y are initial position)
function ball(x, y, isExplosive) {
  this.color = "#AAABC8"
  this.getColor = function() {return this.color}

  this.explosive = (isExplosive == "e")

  this.collide = function(collision_type){
    this.onCollide(collision_type)
  }
  this.onCollide = function(collision_type){
    this.color = "#FF0000"
    if(collision_type == "wall") {
      //maybe implement three strikes before dying?
      this.wallCollider.collide(this.x, this.y);
    } else if (collision_type == "ball") {
        controller.ballHitBall();
    }
  }
  this.wallCollider = (this.explosive) ? new wallExplodeAnimation() : new standardWallCollideAnimation();
  this.radius = 20
  this.getRadius = function(){return this.radius}
  this.velocity = [1-Math.random()*2,1-Math.random()*2] //x and y components of velocity, respectively
  this.x = x//Math.random()*view.gameWidth
  //this.x_prev = null, //previous position is important to calculate angle of movement
  this.y = y//Math.random()* view.gameHeight
  //this.y_prev = null
  this.getX = function(){return this.x};
  this.getY = function(){return this.y};
  //this.getPrevX = function(){return this.x_prev};
  //this.getPrevY = function(){return this.y_prev};

  this.setX = function(new_x){
    //this.x_prev = this.x
    this.x = new_x
  }
  this.setY = function(new_y){
    //y_prev = this.y
    this.y = new_y
  }


  this.getVelocity = function(){return this.velocity};

  this.setVelocity = function(v){this.velocity = v};

  this.highestPoint = function(){return this.y - this.radius}
  this.lowestPoint = function(){return this.y + this.radius}
  this.leftestPoint = function() {return this.x - this.radius}
  this.rightestPoint = function() {return this.x + this.radius}

  //move the ball one increment accorsing to its current velocity and position:
  this.move = function(){
    /*update x-axis position using differential equation dx/dt = v_x*/
    var dx = this.getVelocity()[0] // * dt, but let's just say dt is 1
    var new_x = this.getX() + dx; //Combining this line and the next would slightly increase performanc and readability,
    this.setX(new_x) //but they're separate for the upcoming assert test so it can use new_x
    var dy = this.getVelocity()[1]
    var new_y = cur_y + dy
    this.setY(new_y);
    //remember, take some of these lines out if you wanna really maximize efficiency
    console.assert((this.getX() == new_x) && (this.getY() == new_y))
  }
}
function standardWallCollideAnimation(){
    this.collide = function(x,y){ };
}

function wallExplodeAnimation(){
    var img = "explosion.png"
    duration = 2000
    this.collide = function(x,y) {view.showImgAtFor(img, x, y, duration)}
}

function wall(x,y/*top left x and y*/, w, l/*length and width*/){

  this.x = x;
  this.y = y;
  this.w = w;
  this.l = l;

  this.getX = function(){return x}
  this.getY = function(){return y}
  this.getL = function(){return l}
  this.getW = function(){return w}

  this.highestPoint = function(){return y}
  this.lowestPoint = function(){return y+l}
  this.leftestPoint = function(){return x}
  this.rightestPoint = function(){return x+w}
}

var view = {

  //get canvas, context
  can: null,
  ctx: null,

  init: function(){
    this.can = document.getElementById('mainCanvas')
    this.ctx = this.can.getContext("2d")
  },

  update: function(model){

    var can = this.can;
    var ctx = this.ctx;
    //clear the context:
    ctx.clearRect(0,0, w, h);
    var balls = model.getBalls();

    //Iterate through the balls and display their current attributes:
    for(var j = 0, numBalls = balls.length; j < numBalls; j++){
      ball = balls[j];
      color = ball.getColor()
      ctx.beginPath();
      ctx.fillStyle = color
      ctx.arc(ball.getX(), ball.getY(), ball.getRadius(), 0, 2*Math.PI);
      ctx.fill();
      ctx.closePath();
    }

    for(var j = 0, numWalls = model.walls.length; j < numWalls; j++){
      wall = model.walls[j];
      color = "green"
      ctx.beginPath();
      ctx.fillStyle = color
      //alert(wall.getX() + " " + wall.getY() + ", " + wall.getW() + " " + wall.getL())
      ctx.rect(wall.getX(), wall.getY(), wall.getW(), wall.getL())
      ctx.fill();
      ctx.closePath();
    }

    for(var j = 0, ob = model.userObstacle, pix = ob.getPixels(), numPix = pix.length, rad = ob.getRadius(); j<numPix; j++){
      //get x and y values of the pixel
      x = pix[j][0]
      y = pix[j][1]

      color = "maroon"
      //draw circles of radius rad around each pixel
      ctx.beginPath()
      ctx.fillStyle = color
      ctx.arc(x, y, rad, 0, 2*Math.PI)
      ctx.fill()
      ctx.closePath()

    }


  },

  //img is a link to the image file
  showImgAtFor: function(img, x, y, duration){
    this.overlayCan = document.getElementById("overlay")
    octx = this.overlayCan.getContext('2d')

    var imgElement = new Image();
    imgElement.src = img;
    octx.drawImage(imgElement, x, y)
    //clear it after the duration's up:
    setTimeout(function(){octx.clearRect(x,y,imgElement.width, imgElement.height)}, duration)
    //imgElement.style.position = "absolute"
    //imgElement.style.top = "300"
    //document.body.appendChild(imgElement);

  },

  //display a message to the player
  message: function(msg){alert(msg)}

}

var controller = {

  can : null,
  ctx : null,

  beginGame : function(){
    view.init();
    controller.loadCanvas();
    updateGame();
    this.getWallsFromUser(); //this adds an Event Listener
    },

  ballHitBall : function(){console.log("Game Over")},

  loadCanvas : function(){this.can = document.getElementById("mainCanvas"); this.ctx = this.can.getContext("2d")},

  getWallsFromUser : function(){
    //first, add the event listener for mouseclicks
    document.addEventListener("mousedown", this.findWallDrawingPath);
  },

  findWallDrawingPath : function(event){
    //first, collect the first pixel:
    model.addPixelsToUserObstacle(event)

    document.addEventListener("mousemove", model.addPixelsToUserObstacle);
    //get rid of the mousemove listener when the mouse is released:
    document.addEventListener("mouseup", function(){document.removeEventListener("mousemove", model.addPixelsToUserObstacle)})

  },



}


function updateGame(){
  window.requestAnimationFrame(function(){
    if(!model.gameOver){
      model.update();
      view.update(model);
      window.requestAnimationFrame(updateGame)
    }
  })
}
</script>
</html>
