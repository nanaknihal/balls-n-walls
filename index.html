<!DOCTYPE html>
</html>
<head>
  <title>B a l l s  n'  W a l l s </title>
  <script src="jspsych-6.0.3/jspsych.js"></script>
  <script src="jspsych-6.0.3/plugins/jspsych-html-keyboard-response.js"></script>
  <script src="jspsych-6.0.3/plugins/jspsych-image-keyboard-response.js"></script>
  <link href="jspsych-6.0.3/css/jspsych.css" rel="stylesheet" type="text/css"></link>
</head>

<body>
</body>
<script>
var timeline = []

var welcome = {
  type:"html-keyboard-response",
  stimulus:"Welcome to the game. Press any key to begin"
};
timeline.push(welcome);

var instructions = {
  type:"html-keyboard-response",
  stimulus:"Many balls are innocuous but some are exploding. The exploding balls are briefly shown at the beginning of the level. Then they are no longer highlighted. <br />"+
           "Prevent the exploding balls from hitting the walls by drawing your own walls! Your wall can have multiple edges but the vertices of them cannot be too close! <br />"+
           "That would make it too easy"
};
timeline.push(instructions);

/*width and height: */
w=650; h=650;
var game = {
  type:"html-keyboard-response",
  stimulus: "<!--main canvas where game happens:-->" +
  "<canvas id='mainCanvas' height='" + h + "' width = '" + w + "'></canvas>" + "<button onclick='curLevel.beginGame()'>S T A R T</button>"
  +
  "<!--overlay canvas that doesn't need to be refreshed constantly:-->" +
  //it may be good to not hard-code the top and left value but rather use variables...this will be decided later when we do more styling
  "<canvas id='overlay' style='position:absolute; left: 0; top: 0; z-index:2' height='" + h + "' width = '" + w + "'></canvas>"
  +
  "<!--selection canvas for ball selection in defusal mode:-->" +
  //it may be good to not hard-code the top and left value but rather use variables...this will be decided later when we do more styling
  "<canvas id='selectionCanvas' style='position:absolute; left: 0; top: 0; z-index:1' height='" + h + "' width = '" + w + "'></canvas>"

};
timeline.push(game);

/* CODE FROM THE JSPSYCH TUTORIAL:
var blue_trial = {
  type:"image-keyboard-response",
  stimulus: "img/blue.png",
  choices: ["f","j"]
}

var orange_trial = {
  type: "image-keyboard-response",
  stimulus: "img/orange.png",
  choices: ["f", "j"]
}

var test_stimuli = [
  {stimulus: "img/blue.png", data: {test_part: "test", correct_response: "f"}},
  {stimulus: "img/orange.png", data: {test_part: "test", correct_response:"j"}}]
timeline.push(blue_trial,orange_trial);

var fixation = {
  type: "html-keyboard-response",
  stimulus: "<div style='font-size:60px;'>+</div>",
  choices: jsPsych.NO_KEYS,
  trial_duration: jsPsych.randomization.sampleWithoutReplacement(
    [250, 500, 750, 1000, 1250, 1500, 1750, 2000], 1)[0],
  data: {test_part: "fixation"}
}

var test = {
  type:"image-keyboard-response",
  stimulus:jsPsych.timelineVariable("stimulus"),
  choices:["f","j"],
  data:jsPsych.timelineVariable("data"),
  on_finish: function(data){
    data.correct = data.key_press == jsPsych.pluginAPI.convertKeyCharacterToKeyCode(data.correct_response);
  }
}

var test_procedure = {
  timeline:[fixation, test],
  timeline_variables: test_stimuli,
  randomize_order: true,
  repetitions: 5
}
timeline.push(test_procedure);
*/
ballColor = "grey"
jsPsych.init({
  timeline: timeline,
  on_finish: function(){
    jsPsych.data.displayData();
  }
})

var randomOneOrNegativeOne = function(){return Math.random()< 0.5 ? -1 : 1}

//takes two arrays of length 2 representing points
var distanceBetween = function(p1, p2){
  var xdist = p2[0]-p1[0]
  var ydist = p2[1]-p1[1]
  return Math.sqrt(xdist*xdist + ydist*ydist)
}

/*--Game stuff:--*/

function model(numBalls, numExplodingBalls, speed) {
  this.frozen = false //game pauses and model freezes
  this.freeze = function(){this.frozen = true}
  this.currentTime = 0
  this.balls = []; //including exploding balls
  this.explodingBalls = [];
  this.numExplodingBalls = function(){return this.explodingBalls.length}

  for(var i = 0; i<numBalls; i++){
    var ballRadius = 20
    //random x-y coordinates of a new ball:
    x = Math.round(ballRadius + Math.random()*(w-2*ballRadius));
    y = Math.round(ballRadius + Math.random()*(h-2*ballRadius));
    this.balls.push(new ball(x,y,ballRadius, speed))
  }

  for(var i = 0; i<numExplodingBalls; i++){  //exploding balls can't be too close to the edges; that isn't fair
    x = Math.round(10*ballRadius + Math.random()*(w-20*ballRadius));
    y = Math.round(10*ballRadius + Math.random()*(h-20*ballRadius));
    bal = new ball(x,y,ballRadius,speed, "e") //e for explosive
    this.balls.push(bal)
    this.explodingBalls.push(bal)
  }


  /*MAKE SURE TO NOT MAKE THE WIDTHS NEGATIVE - THE wall.highestPoint, leftestPoint, etc. methods will not work if they
   *are negative. It may be a good idea to make those methods work with negative values, but it seems that would be less
   *efficient because more steps would be involved in those methods, which are called a lot. It also may be good to have
   *the highestPoint, lowestPoint, etc. methods of the four walls at the edges of the canvas only be called once instead
   *of for every ball in every update. Also make sure the balls are not already touching the walls upon initialization*/
   this.walls = [new wall(0,0,w,1), new wall(0,0,1,h), new wall(0,h-2,w,1), new wall(w-2,0,1,h)], //default border walls of 0px

  /*USER OBSTACLE: a set of pixels that the user selected to be included in the "obstacle." The user probably sees this as
   *"obstacle" as multiple obstacles, but the program treats them all as one. It doesn't care how the pixels are grouped,
   *just where they are.
   *
   *The obstacle has a radius. If a ball is closer than ball.radius + obstacle.radius, a collision will be registered */

    this.userObstacle = {
      pixels : new Array(),
      radius : 4,
      maxPixels: 5,
      minDistanceBetweenPixels: 200,
      //minDistanceToCallItSamePixelSquared: 300,
      pixelLimitExceeded: false,

      addPixels : function(event){
        //if there are no existing pixels/points, just add it without the for loop
        numPix = this.pixels.length;
        if(numPix == 0){
          this.pixels.push([event.pageX, event.pageY])
          return; //break it so the function doesn't try to add the value again
        }
        var validPosition = true
        //add them if they're far enough from the previous pixels.
        for(var l=0; l<numPix; l++){
          if(distanceBetween([event.pageX, event.pageY], this.pixels[l]) < this.minDistanceBetweenPixels){
             validPosition = false;
             break;
          }
        }

        if(validPosition){
            this.pixels.push([event.pageX, event.pageY])
          }

        while(this.pixels.length > this.maxPixels){

          //console.log(this.pixels)
          this.pixels.shift() //get rid of the first element
          //console.log(this.pixels)
        }
        //console.log(this.pixels)
      },

/*
        if(([event.pageX, event.pageY]){} //if(this.pixels.length == this.maxPixels){
          this.pixels.push([event.pageX, event.pageY])
        } else if (this.pixels.length >= this.maxPixels) {
          //if this is the first time exceeding the pixel limit:
          if(!this.pixelLimitExceeded){
            view.message("You can't use too much wall... that would make it easy")
            //set it to true so this message only displays once:
            this.pixelLimitExceeded = true;
          }


        }
      },*/
      getPixels : function(){return this.pixels},
      getRadius : function(){return this.radius}
    },


  //not necessary to have this function but it's good encapsulation and helps with Law of Demeter (even though it technically violates it)
  //if efficiency is a concern, we can get rid of it:
  this.addPixelsToUserObstacle = function(event){
    curLevel.model.userObstacle.addPixels(event)
  }


  this.getBalls = function(){return this.balls},
  this.update = function(newTime){
   if(!this.frozen){ //don't update if it's frozen
    timestepDuration = newTime - this.currentTime
    this.currentTime = newTime


    //check for collision with any previously updated balls:
    //commenting this out because we don't need collisions (maybe will implement later)
    /*
    var ballCollided = false;
    //assuming all balls have same, constant radius! that seems fine for the purpose of this experiment (and is much better for efficiency):
    rad = ball.getRadius();
    rad2 = rad*rad;
    for(var k = 0, numUpdBalls = updatedBalls.length; k < numUpdBalls && !ballCollided/*it will stop on collisions; k++){
      x_diff = cur_x - updatedBalls[k].getX();
      y_diff = cur_y - updatedBalls[k].getY();
      distance = Math.pow(x_diff, 2) + Math.pow(y_diff, 2);



      if(distance < rad2){
        ballCollided == true;
        ball.collide("ball");

      }
    }*/


    //Checks for collision with the four walls surrounding the game, NOT user-defined obstacles/walls
    this.checkForWallCollisions = function(){
    /*update the balls*/

    for(var i = 0, numBalls = this.balls.length; i < numBalls; i++){

      var ball = this.balls[i];
      ballPoint = [ball.getX(), ball.getY()]

      for(var k = 0, numWalls = this.walls.length; k < numWalls; k++){

        wall = this.walls[k]


        wallX = wall.getX()
        wallY = wall.getY()
        wallL = wall.getL()
        wallW = wall.getW()


        rad = ball.getRadius()

        //var bh = ball.highestPoint()
        //var bl = ball.lowestPoint()
        //var be = ball.leftestPoint()
        //var br = ball.rightestPoint()

        var wh = wall.highestSide()
        var wl = wall.lowestSide()
        var we = wall.leftestSide()
        var wr = wall.rightestSide()

        /*WHEN A BALL INTERSECTS WITH A WALL:
          one of the rectangle's four edges is within the circle's area (closer to the center than the circle).
          When this happens, the circle's center will be closer to a vertical wall's x coordinate than it's radius is
          AND the circle's highest or lowest point will be within the wall's highest and lowest points

          OR

          vice versa with horizontal walls and y coordinates vs. x coordinates
        */

        //NOTE: you can increase the padding for better performance withhigher velocities
        padding = 3
        function oneDimDistance(a,b) {return Math.abs(a-b)} //his is just encapsulation of a simple but soon-to-be frequently used procedure

        closestSideOfWallVertically = (oneDimDistance(ballPoint[1], wh) < oneDimDistance(ballPoint[1], wl)) ? wh : wl

        closestSideOfWallHorizontally = (oneDimDistance(ballPoint[0], we) < oneDimDistance(ballPoint[0], wr)) ? we : wr

        closestVertDistance = oneDimDistance(ballPoint[1], closestSideOfWallVertically)
        closestHoriDistance = oneDimDistance(ballPoint[0], closestSideOfWallHorizontally)
        console.log(closestSideOfWallVertically, closestSideOfWallHorizontally)
        if(closestVertDistance <= rad+padding || closestHoriDistance <= rad+padding){
          ball.collide("wall");
          //multiply the velocity by -1 on appropriate axis. but how do we find the appropriate axis?:
          //by looking for the side of the wall the ball is closest to

            closestWall = "both" //default value. this is usefeul when the ball collides with both at the same time (which is very rare)

            if(closestVertDistance < closestHoriDistance){
              closestWall = "vert"
            } else if(closestHoriDistance < closestVertDistance){
              closestWall = "hori"
            }

            //now, find and set the ball's velocity
            vel = ball.getVelocity()
            switch(closestWall){
            case "vert":
              ball.setVelocity([vel[0], -vel[1]])
              break
            case "hori":
              ball.setVelocity([-vel[0], vel[1]])
              break
            case "both":
              ball.setVelocity([-vel[0], -vel[1]])
              break

            }

          //move the ball one increment after setting its velocity (or leaving it):
          }
        }
      }
    }

    this.checkForObstacleCollisions = function(){
      /***********
      //iterate through all the balls and pixels
      for(var i = 0, numBalls = this.balls.length; i < numBalls; i++){
        ball = this.balls[i]
        for(var j = 0, ob = model.userObstacle, pix = ob.getPixels(), numPix = pix.length; j<numPix; j++){
          //if the pixel is within the ball's radius:
            a = Math.abs(pix[j][0] - ball.getX())
            b = Math.abs(pix[j][1] - ball.getY())
            c = ball.getRadius() + ob.getRadius()
            if(a*a + b*b <= c*c){
              //collision has happened! change ball's velocity accordingly:
              //find the neighboring two pixels to calculate the angle of collision at a "miniwall" of 3 pixels:
              p0 = (j == 0 ? pix[j] : pix[j-1]) //if j's 0, there is no pix[j-1] so it should use pix[j] as the starting point
              p1 = (j < numPix-1 ? pix[j+1] : pix[j])

              miniWallXComponent = p1[0]-p0[0] //make sure these work with negative x or y components
              miniWallYComponent = p0[1]-p1[1] //remember, y-axis is flipped on displays

              //arctan of y comp / x comp:
              miniWallAngleFromXAxis = Math.atan2(miniWallYComponent, miniWallYComponent)
              console.log(miniWallAngleFromXAxis*180/Math.PI)
              miniWallAngleFromYAxis = Math.PI/2-miniWallAngleFromXAxis

              vi = ball.getVelocity()
              viAngleFromYAxis = Math.atan2(vi[0], vi[1])

              angleBetweenViAndObstaclePoint = miniWallAngleFromYAxis - viAngleFromYAxis //this equals angle_between_vf_and_obstacle_point
                                                                                              //(which isn't an actual variable here)

              angleBetweenVfAndXAxis = Math.PI/2 + miniWallAngleFromXAxis - angleBetweenViAndObstaclePoint //this is easier to see visually

              vMagnitude = Math.sqrt(vi[0]*vi[0] + vi[1]*vi[1]) //Pythagorean theorem

              vfX = vMagnitude * Math.cos(angleBetweenVfAndXAxis)
              vfY = vMagnitude * Math.sin(angleBetweenVfAndXAxis)
              ball.setVelocity([vfX, vfY])
              console.log(vi)
              console.log(vfX,vfY)
              //console.log(ball.getVelocity())
              ball.move()
            }
        }
      }*///////////


      //iterate through all the balls and pixels (except last pixel because there will be no line drawn from it):
      for(var i = 0, numBalls = this.balls.length; i < numBalls; i++){
        ball = this.balls[i]
        rad = ball.getRadius()
        for(var j = 0, ob = this.userObstacle, pix = ob.getPixels(), numPix = pix.length; j<numPix-1; j++){
          //compute distance between ball center and closest point on wall:
            //first find intersection of ball velocity vector and wall:
              //step 1. compute equations of lines (in slope-intercept form)
                var equation = function(m,b){
                  this.m = m;
                  this.b = b;
                  //getters and setters are probably unecessary
                }

                //arguments: point in form [x,y] and vec in form [xComponent, yComponent]
                function equationFromPointAnd2dVec(point, vec){
                  var slope = vec[1]/vec[0]
                  var intercept = point[1] - slope*point[0]
                  return new equation(slope, intercept)
                }

                function intersectionOf2Equations(e1, e2){
                    x = (e2.b-e1.b)/(e1.m-e2.m)
                    y = e1.m*x+e1.b
                    console.assert(Math.round(y) == Math.round(e2.m*x+e2.b))//remove this for production if we reeally need an insignificant efficiency boost -
                                                                            //just checking whether both equations give the same y value for the x value
                    return [x,y]
                }

                ballPoint = [ball.getX(), ball.getY()]
                ballVec = ball.getVelocity()
                ballTrajectoryEquation = equationFromPointAnd2dVec(ballPoint, ballVec)

                wallPoint = pix[j]
                nextWallPoint = pix[j+1]
                wallVec = [nextWallPoint[0]-wallPoint[0], nextWallPoint[1]-wallPoint[1]]
                wallExtensionEquation = equationFromPointAnd2dVec(wallPoint, wallVec)

                intersection = intersectionOf2Equations(ballTrajectoryEquation,wallExtensionEquation)



                /*Now that the intersection has been found, find the angle between the velocity and the wall*/
                /*Make sure the SIGNS OF ALL THESE ANGLES ARE CORRECT:*/
                angleBetweenVelocityAndXAxis = Math.atan2((intersection[1]-ballPoint[1]), (intersection[0]-ballPoint[0]))
                angleBetweenWallAndYAxis = Math.PI/2-Math.atan(wallExtensionEquation.m)
                angleBetweenVelocityAndWall = Math.PI/2 - angleBetweenVelocityAndXAxis - angleBetweenWallAndYAxis
                angleBetweenWallAndXAxis = Math.PI/2 - angleBetweenWallAndYAxis
                ballToIntersectionDistance = Math.sqrt(Math.pow(intersection[0]-ballPoint[0], 2) + Math.pow(intersection[1]-ballPoint[1], 2)) //Pythagorean


                //The ball can be touching the wall even if it doesn't intersect, so we need to find the distance to the closest point on the wall:
                //The line between this and the ball is always pi/2 radians from the ball, so we can use the sin:

                ballToWallClosestDistance = ballToIntersectionDistance * Math.sin(angleBetweenVelocityAndWall)//MATH.ABS?

                ballWithinLineRange = false
                if(Math.abs(ballToWallClosestDistance) < Math.abs(rad)){
                  ballWithinLineRange = true
                }

                /*NOT USING THIS METHOD ANYMORE:*/
                /*Now, find the exact point where the closest line from ball-to-wall intersects with the wall. This is the point of collision,
                 *and is different than the point of intersection, where the velocity vector intersects with the wall. Unfortunately,
                 *this cannot easily be done with the previous methods (equationFromPointAnd2dVec, etc.) because only the vector's magnitudes are known
                 *as a result, a different method is used: first, finding the distance between the collision point and the velocity-wall intersection point.
                 *This is ballToWallClosestDistance/tan(angleBetweenVelocityAndWall).
                 *We already know the slope of the wall (wallExtensionEquation.m), so we need to figure out what point is x distance away, where x is the
                 *distance we just calculated between the collision and interserction.

                 *The "run" and "rise" (x-distance and y-distance between the collision and intersection points) have a certain relationship:
                 *rise/run = wallExtensionEquation.m. Also, rise^2 + run^2 = ballToWallClosestDistance. These two equations can be solved for.
                 *Solving for rise, the resulting equation is rise = Math.sqrt(
                 (-Math.pow(distanceFromVIntersectionToCollision,2) + Math.sqrt(Math.pow(distanceFromVIntersectionToCollision, 4) - 4*Math.pow(wallExtensionEquation.m, 2)))/2
               )
                  *run is just rise/wallExtensionEquation.m


                  var distanceFromVIntersectionToCollision = ballToWallClosestDistance/Math.tan(angleBetweenVelocityAndWall)
                  //parameters for quadratic formula used to calculate rise. These parameters were figured out by hand. They appear in the above
                  //comment althouh just as their values, not as a, b, or c. In the actual code, the equation is made simpler by substituting a, b,
                  //and c for their respective values, so that the code is easier to read (and possibly slightly more efficient because b is not recalculated)
                  //var a = 1
                  var b = Math.pow(distanceFromVIntersectionToCollision,2)
                  var c = Math.pow(wallExtensionEquation.m, 2)
                  var rise = Math.sqrt(
                   (-b + Math.sqrt(b*b - 4*c))/2 //This is the quadratic equation
                  ) //then the solution to the equation is square-rooted. The result value of rise as determined by solving the system of equations mentioned.

                  var run = rise/wallExtensionEquation.m

                  //Now, find the actual point of collision:
                  collisionPoint = [intersection[0]-run, intersection[1]-rise] */


                 /*USING THIS:*/
                 //See diagrams //NOTE: ADD DIAGRAMS
                 distanceBetweenCollisionAndIntersection = ballToIntersectionDistance * Math.sin(Math.PI/2 - angleBetweenVelocityAndWall)

                 HoriDistanceBetweenCollisionAndIntersection = Math.sqrt(distanceBetweenCollisionAndIntersection*distanceBetweenCollisionAndIntersection /
                                                                        (wallExtensionEquation.m*wallExtensionEquation.m + 1))
                 //slope (m) = vertical-distance/horizontal-distance
                 VertDistanceBetweenCollisionAndIntersection = /*-/ABS?*/ wallExtensionEquation.m*HoriDistanceBetweenCollisionAndIntersection

                 collisionPoint = [intersection[0]-HoriDistanceBetweenCollisionAndIntersection, intersection[1]-VertDistanceBetweenCollisionAndIntersection]

                //Check whether the collision point is actually within the wall and not just in its extension
                collisionIsWithinSegment = (collisionPoint[0] >= Math.min(wallPoint[0], nextWallPoint[0])) &&
                                                             (collisionPoint[0] <= Math.max(wallPoint[0], nextWallPoint[0])) &&
                                                             (collisionPoint[1] >= Math.min(wallPoint[1], nextWallPoint[1])) &&
                                                             (collisionPoint[1] <= Math.max(wallPoint[1], nextWallPoint[1]))
                //Consider the following scenario: the collisionPoint is not actually the closest point on the wall's extension. This happens when the ball collides with
                // an endpoint of the wall. For these cases:
                if(!collisionIsWithinSegment && ((distanceBetween(ballPoint, wallPoint) <= rad || distanceBetween(ballPoint, nextWallPoint) <=rad))){
                  //alert("a")
                  collisionIsWithinSegment = true;
                  ballWithinLineRange = true;
                  collisionPoint = wallPoint;
                }
                //view.showPoint(collisionPoint)
                //console.log(angleBetweenVelocityAndWall*57.3)
                //alert(ballToWallClosestDistance + ", " + collisionIsWithinSegmentPlusBallRadius + ", " + ballWithinLineRange + ", " + collisionPoint)
                //if(!collisionIsWithinSegment && ballWithinLineRange){console.log(collisionPoint)}

                if(collisionIsWithinSegment && ballWithinLineRange){
                  //there's a collision
                  ball.collide(ball)
                  //sometimes, the balls can end up in the walls. The user should be allowed to draw walls through balls,
                  //and the balls can occasionally find their way into walls. In these cases, balls should just pass through
                  //and their velocities should not be changed. Hence,
                  ballIsInsideWall = Math.abs(ballToWallClosestDistance) + 8 < rad //8px is given as leeway
                  //alert(angleBetweenVelocityAndWall*57.3)
                  if(!ballIsInsideWall){

                    //calculate resulting velocity (Vf):

                    //sometimes the angle of collision is very small and the resulting angle is calculated as being the same. In these cases, the angle should be
                    //artificially increased:
                    if(Math.abs(angleBetweenVelocityAndWall) < 0.1){alert(angleBetweenVelocityAndWall); angleBetweenVelocityAndWall = angleBetweenVelocityAndWall*100}
                    angleBetweenResultingVelocityAndXAxis = angleBetweenWallAndXAxis + angleBetweenVelocityAndWall
                    //alert(angleBetweenWallAndXAxis + ":" + angleBetweenVelocityAndWall)

                    //now, we know the angle of the velocity. we just need the magnitute:
                    velMagnitude = Math.sqrt(ballVec[0]*ballVec[0] + ballVec[1]*ballVec[1])
                    resultingVelXComponent = velMagnitude*Math.cos(angleBetweenResultingVelocityAndXAxis)
                    resultingVelYComponent = velMagnitude*Math.sin(angleBetweenResultingVelocityAndXAxis)
                    //alert(angleBetweenVelocityAndWall*57.3)//"previous velocity:" + ball.getVelocity() + ", new velocity:" + [resultingVelXComponent, resultingVelYComponent])
                    ball.setVelocity([resultingVelXComponent, resultingVelYComponent])

                    ball.dontCollideFor(100)
                    //setTimeout(function(){ball.setVelocity([-resultingVelXComponent, resultingVelYComponent])}, 500)
                }
                }
              }
            }
          }
    this.checkForWallCollisions()
    this.checkForObstacleCollisions()
    //move the balls
    for(var i = 0, numBalls = this.balls.length; i < numBalls; i++){
      this.balls[i].move()
    }

  }
 }

 this.checkDefusalGuess = function(clickPoint){
   //alert("Checkin'")
    clickIsInABall = false
    balls = curLevel.model.getBalls()
    for(var k = 0, numBalls = balls.length; k < numBalls; k++){
      if(distanceBetween(clickPoint, [balls[k].getX(), balls[k].getY()] ) <= balls[k].getRadius()){
        clickIsInABall = true
        if(ball.isBallExplosive() && !curLevel.controller.ballWasAlreadyGuessed(ball)){curLevel.controller.addGuessedBall(ball); return true}
      }
    }
    //after iterating through all of them and none of them beign correct guesses (because correct guesses would have resulted in return true)
    if(clickIsInABall){
      return false
    } else {return "notABall"}
  }
}

//constructor for balls: (x and y are initial position)
function ball(x, y, radius, speed, isExplosive) {
  this.endTimeout = function(){this.NoSetVelocity = false}
  this.initiateTimeout = function(){
  this.NoSetVelocity = true
    setTimeout(this.endTimeout,10)
  }
  this.dontCollideFor = function(ms){
    this.initiateTimeout()
  }
  this.color = ballColor
  this.getColor = function() {return this.color}
  this.setColor = function(col) {this.color = col}
  this.explosive = (isExplosive == "e")
  this.isBallExplosive = function(){return this.explosive}
  this.collide = function(collision_type){
    if(collision_type == "wall" && this.explosive){
      curLevel.defusalMode() //COMMENT THIS TO DISABLE DEFUSAL MODE
    }
    this.onCollide(collision_type)
  }
  this.onCollide = function(collision_type){
    //this.color = "#FF0000"
    if(collision_type == "wall") {
      this.wallCollider.collide(this.x, this.y);
    } else if (collision_type == "ball") {
        controller.ballHitBall();
    }
  }
  this.wallCollider = (this.explosive) ? new wallExplodeAnimation() : new standardWallCollideAnimation();
  this.radius = radius
  this.getRadius = function(){return this.radius}
  //all balls must have the same speed but random direction: therefore their:
  //x velocity = their speed*cos(random angle), y velocity: speed*sin(same angle)

  var randomAngle = Math.random()*2*Math.PI
  this.velocity = [speed*Math.cos(randomAngle), speed*Math.sin(randomAngle)]
  this.x = x//Math.random()*view.gameWidth
  //this.x_prev = null, //previous position is important to calculate angle of movement
  this.y = y//Math.random()* view.gameHeight
  //this.y_prev = null
  this.getX = function(){return this.x};
  this.getY = function(){return this.y};
  //this.getPrevX = function(){return this.x_prev};
  //this.getPrevY = function(){return this.y_prev};

  this.setX = function(new_x){
    //this.x_prev = this.x
    this.x = new_x
  }
  this.setY = function(new_y){
    //y_prev = this.y
    this.y = new_y
  }


  this.getVelocity = function(){return this.velocity};

  this.setVelocity = function(v){
      if(!this.velocityTimeoutOn){
        this.velocity = v
      }
  }

  this.highestRow = function(){return this.y - this.radius}
  this.lowestRow = function(){return this.y + this.radius}
  this.leftestColumn = function() {return this.x - this.radius}
  this.rightestColumn = function() {return this.x + this.radius}

  //move the ball one increment accorsing to its current velocity and position:
  this.move = function(){
    //account for strange timestepDuration values like 0 or very high values:
    if(timestepDuration == 0 | timestepDuration > 400){
      timestepDuration = 30
    }
    /*update x-axis position using differential equation dx/dt = v_x*/
    var dx = this.getVelocity()[0] * timestepDuration
    var newX = this.getX() + dx;
    this.setX(newX)
    var dy = this.getVelocity()[1] * timestepDuration
    //console.log(timestepDuration)
    var newY = this.getY() + dy
    this.setY(newY);
    //remember, take some of these lines out if you wanna really maximize efficiency
    //console.assert((this.getX() == new_x) && (this.getY() == new_y))
    //if(Math.abs(this.getVelocity()[0]) > 2 || Math.abs(this.getVelocity()[1]) > 2){console.log("slow down")}
  }
}
function standardWallCollideAnimation(){
    this.collide = function(x,y){ };
}

function wallExplodeAnimation(){
    var img = "explosion.png"
    duration = 2000
    this.collide = function(x,y) {view.showImgAtFor(img, x, y, duration)}
}

function wall(x,y/*top left x and y*/, w, l/*length and width*/){

  this.x = x;
  this.y = y;
  this.w = w;
  this.l = l;

  this.getX = function(){return x}
  this.getY = function(){return y}
  this.getL = function(){return l}
  this.getW = function(){return w}

  this.highestSide = function(){return y}
  this.lowestSide = function(){return y+l}
  this.leftestSide = function(){return x}
  this.rightestSide = function(){return x+w}
}

var view = {
  //get canvas, context
  can: null,
  ctx: null,
  highlightingSelectedBalls: false,
  pointsToShow: new Array(),
  showPoint: function(pt) {this.pointsToShow.push(pt)},

  init: function(){
    this.can = document.getElementById('mainCanvas')
    this.ctx = this.can.getContext("2d")
  },

  showInitialFrame(model, duration){
    //just call view's update function once. However, the exploding balls' colors must be changed. TODO: add a nice countdown animation on top, on the overlay canvas maybe

    //change the exploding balls' colors:
    for(var j = 0, balls = model.getBalls(), numBalls = balls.length; j < numBalls; j++){
      ball = balls[j];
        if(ball.isBallExplosive()){

        ball.setColor("orange")
        setTimeout(function(){curLevel.resetAllBalldesigns(curLevel.model)},duration) //this works, it sets both ///delete this comment later when it's unecessary
      }

    }
    this.update(model)
  },

  update: function(model){
    //var can = this.can;
    var ctx = this.ctx; //easier to work with than having to write this.ctx each time
    //clear the context:
    ctx.clearRect(0,0, w, h);
    var balls = model.getBalls();

    //Iterate through the balls and display their current attributes:
    for(var j = 0, numBalls = balls.length; j < numBalls; j++){
      ball = balls[j];
      color = ball.getColor()
      ctx.beginPath();
      ctx.fillStyle = color
      ctx.arc(ball.getX(), ball.getY(), ball.getRadius(), 0, 2*Math.PI);
      ctx.fill();
      ctx.closePath();
    }

    for(var j = 0, numWalls = model.walls.length; j < numWalls; j++){
      wall = model.walls[j];
      color = "green"
      ctx.beginPath();
      ctx.fillStyle = color
      //alert(wall.getX() + " " + wall.getY() + ", " + wall.getW() + " " + wall.getL())
      ctx.rect(wall.getX(), wall.getY(), wall.getW(), wall.getL())
      ctx.fill();
      ctx.closePath();
    }

    //display the points/pixels in the user-defined wall as circles and draw line segments between them (except for before the first and after the last pixel)
    for(var j = 0, ob = model.userObstacle, pix = ob.getPixels(), numPix = pix.length, rad = ob.getRadius(); j<numPix; j++){
      //get x and y values of the pixel
      x = pix[j][0]
      y = pix[j][1]

      color = "maroon"
      //draw circles of radius rad around each pixel
      ctx.beginPath()
      ctx.fillStyle = color
      ctx.arc(x, y, rad, 0, 2*Math.PI)
      ctx.fill()

      //then draw a line from the pixel to the next pixel (if the next pixel exists)
      if(j < numPix-1){
        ctx.fillStyle = color
        ctx.moveTo(pix[j][0], pix[j][1])
        ctx.lineTo(pix[j+1][0], pix[j+1][1])
        ctx.stroke();
      }

      ctx.closePath()

    }

    //show the points:
    for(var j = 0, pix = this.pointsToShow, numPix = pix.length; j<numPix; j++){
      x = pix[j][0]
      y = pix[j][1]

      color = "black"
      //draw circles of radius rad around each pixel
      ctx.beginPath()
      ctx.fillStyle = color
      ctx.arc(x, y, 3, 0, 2*Math.PI)
      ctx.fill()
      ctx.closePath();
    }

  },

  //img is a link to the image file
  showImgAtFor: function(img, x, y, duration){
    ocan = document.getElementById("overlay")
    octx = ocan.getContext('2d')
    var imgElement = new Image();
    imgElement.src = img;
    octx.drawImage(imgElement, x, y)
    //clear it after the duration's up:
    setTimeout(function(){octx.clearRect(x,y,imgElement.width, imgElement.height)}, duration)
    //imgElement.style.position = "absolute"
    //imgElement.style.top = "300"
    //document.body.appendChild(imgElement);

  },

  //display a message to the player
  message: function(msg){alert(msg)},

  displayDefusalMessage: function(defusalTimeLimit){

    ocan = document.getElementById("overlay")
    octx = ocan.getContext('2d')

    octx.font = "30px Helvetica"
    octx.strokeText("Defusal Mode", w/2, h/3)

    octx.font = ("12px Arial")

    octx.fillText("You have " + defusalTimeLimit/1000 + " seconds to defuse the bombs by clicking the correct balls", w/2, 2*h/3)
  },

  highlightSelectedBalls: function(event){
    can = document.getElementById('selectionCanvas')
    ctx = can.getContext('2d')
    //iterate through the balls to check whether the mouth is within them:
    balls = curLevel.model.getBalls()
    for(var j = 0, numBalls = balls.length; j < numBalls; j++){
      ball = balls[j]
      if(distanceBetween([event.pageX,event.pageY], [ball.getX(), ball.getY()]) < ball.getRadius()){
        //display a border around the ball
        ctx.beginPath()
        ctx.fillStyle = ball.getColor()
        var selectionRadiusAddOn = 1
        var totalRadius = ball.getRadius()+selectionRadiusAddOn
        ctx.arc(ball.getX(), ball.getY(), totalRadius, 0, 2*Math.PI)
        ctx.stroke()
        ctx.closePath();

      } else {
        //clear the rect aronud the ball
        var totalDiameter = totalRadius * 2
        ctx.beginPath()
        ctx.rect(ball.getX()-totalRadius-1, ball.getY()-totalRadius-1, totalDiameter+2, totalDiameter+2)
        ctx.stroke()
        ctx.closePath()
      }

    }

    //recursive call
    /*if(curLevel.isDefusalModeOn()){
      window.requestAnimationFrame(view.highlightSelectedBalls)
      alert("reqanfr")
    }*/
  },
  //timer displaying:
  timer : {
    hidden: false, //toggle whether it's displayed
    hide: function() {this.hidden = true},
    color: "red",
    fontSize:12,
    x: w/2, // x positioning
    y: 10,
    countdown: true, //default is countdown-mode, not countup-mode
    countdownTime: null,
    startTime: 0, //null, (it needs to be set)
    curTime: null,
    updateCurTime: function(){view.timer.curTime = Math.abs(this.startTime - new Date().getSeconds())}, //startDate must be set already for this to work properly. note times will reset after a minute.
    //updateCurTime: function(){this.curTime++},
    reset: function(countdownTime, color, countdown) {
      this.countdownTime = countdownTime;
      this.startTime = new Date().getSeconds(); //0
    },


    displayTimer: function(){
      //draw timer:
      octx = document.getElementById("overlay").getContext("2d")
      if(this.hidden){
        return null //exit the function if it's hidden, before the recursive call
      }
        //ocan = document.getElementById("overlay")
        //octx = ocan.getContext('2d')
        octx.clearRect(this.x,this.y-this.fontSize, this.fontSize*2, this.fontSize)
        octx.font = this.fontSize + "px Arial"
        //time = Math.round((this.curTime % 60000)/1000)
        time = this.curTime == null ? 0:this.curTime
        octx.fillText(time, this.x, this.y) //NOTE: assuming time counter should always be under a minute

        setTimeout(function(){view.timer.updateCurTime();view.timer.displayTimer();}, 1000) //recursive call
      }

    }




}

function controller(model, view,levelDuration){

  this.gameOver = false
  this.defusalModeOn = false
  this.isGameOver = function(){return this.gameOver} //overdoing it on the getters, setters, and LoD? maybe
  this.beginGame = function(){

    view.init();
    this.loadCanvas();

    var initialFrameDuration = 1300 //ms
    view.showInitialFrame(model,initialFrameDuration) //show the frame where the exploding balls look different

    //then start the first update
    this.getWallsFromUser(); //this adds an Event Listener
    setTimeout(function(){
      //view.timer.reset(levelDuration, "green") //violation of LoD but I think it's ok
      //view.timer.displayTimer() FIGURE OUT WHY THIS METHOD (OR MAYBE THE RESET?) MAKES IT LAGGY
      updateGame(0, this.model); //beginning time is 0
    }, duration)
    }

  this.ballHitBall = function(){console.log("Game Over")},

  this.loadCanvas = function(){this.can = document.getElementById("mainCanvas"); this.ctx = this.can.getContext("2d")},

  this.getWallsFromUser = function(){
    //first, add the event listener for mouseclicks
    document.addEventListener("mousedown", this.findWallDrawingPath);
  },

  this.findWallDrawingPath = function(event){
    //first, collect the first pixel:
    model.addPixelsToUserObstacle(event)

    document.addEventListener("mousemove", model.addPixelsToUserObstacle);
    //get rid of the mousemove listener when the mouse is released:
    document.addEventListener("mouseup", function(){document.removeEventListener("mousemove", model.addPixelsToUserObstacle)})

  }

  this.defusalMode = function(){

    //only start defusalMode if it's not on already - this prevents it being triggered multiple times by collisions:
    if(!this.defusalModeOn){
      this.defusalModeOn = true
      defusalTimeLimit = 10000
      view.displayDefusalMessage(defusalTimeLimit)
      //remove the wall drawing listeners
      document.removeEventListener("mousedown", this.findWallDrawingPath)
      document.removeEventListener("mousemove", model.addPixelsToUserObstacle)

      //listen for new guesses:
      document.addEventListener("mousemove", view.highlightSelectedBalls)
      document.addEventListener("mousedown", this.registerDefusalGuess)

      //start the timer
      view.timer.reset(defusalTimeLimit/100, "red")
      view.timer.displayTimer()



      setTimeout(function(){
        if(curLevel.controller.defusalModeOn){ //if the level hasn't been changed yet, the game's over after the timer's up //violation of LoD, maybe fix
          curLevel.controller.endGame()
        }},
      defusalTimeLimit)
    }

  }

  guessesRemaining = model.numExplodingBalls()
  //alert(guessesRemaining)
  correctGuesses = 0
  incorrectGuesses = 0
  this.registerDefusalGuess = function(event){
    if(guessesRemaining > 0){
      result = model.checkDefusalGuess([event.pageX, event.pageY])
      switch(result){
        case true: //correct guess
          correctGuesses++
          guessesRemaining--
          alert(guessesRemaining)
          break;
        case false:
          incorrectGuesses++
          guessesRemaining-- //-- instead of set to 0 because then we can collect data about how many the got right/wrong
          alert(guessesRemaining)
          break;
        case "notABall":
          break;

      }

    } else { //if there are no guesses remaining:
      //alert(guessesRemaining)
      //remove the guessing event listeners
      document.removeEventListener("mousedown", this.registerDefusalGuess)
      document.removeEventListener("mousemove", view.highlightSelectedBalls)

    }

  }

  guessedBalls = [];
  this.ballWasAlreadyGuessed = function(ball){return guessedBalls.includes(ball)}
  this.addGuessedBall = function(ball){guessedBalls.push(ball)}
  this.endGame = function(){
    view.timer.hide()
    alert("Game Over...Restarting")
    curLevel = levelZero()
  }


}

//takes a model as an argument. It may be good to make view and controller as arguments, but I don't foresee a realy use in doing so
//edit: also takes levelDuration now, in ms.
function level(mod, levelDuration) {
  this.model = mod
  this.view = view,
  this.controller = new controller(this.model, this.view, duration),
  this.gameOver = function(){return this.controller.isGameOver()}
  this.update = function(currentTime){
     this.model.update(currentTime)
     this.view.update(this.model)
  }
  this.beginGame = function(){
    this.controller.beginGame()
  }
  this.defusalMode = function(){
    this.model.freeze()
    this.controller.defusalMode()
  }
  this.isDefusalModeOn = function(){ return controller.defusalModeOn; alert("im beign called")}

  this.resetAllBalldesigns = function(model){
    balls = model.getBalls()
    for(var m=0, numBalls = balls.length; m<numBalls; m++){
      balls[m].setColor(ballColor); console.log(ball.getColor())
    }
  }
}



function levelZero() {return new level(new model(4,4,0.04))}

curLevel = levelZero();

function updateGame(currentTime){
  window.requestAnimationFrame(function(){
    if(!curLevel.gameOver()){
      curLevel.update(currentTime);
      window.requestAnimationFrame(updateGame)
    }
  })
}


</script>
</html>
